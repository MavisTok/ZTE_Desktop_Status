下面我结合你上传的 **`192.168.0.1.har` 抓包文件**，把这个路由器 Web 登录流程“**怎么实现** / **前后端如何交互** / **关键点是什么**”做一个比较完整的分析（偏工程实现视角）。

---

## 1）整体登录流程（从 HAR 里看到的真实顺序）

从抓包结果看，登录不是传统的 `/login` 表单提交，而是一个典型的 **前端页面 + JSON-RPC API（ubus）** 架构：

### ✅ Step A：加载登录页面资源

浏览器先访问：

* `GET http://192.168.0.1/tmpl/auth/home.html`
* `GET http://192.168.0.1/js/auth/home.js`

说明：

* `home.html` 是登录页模板
* `home.js` 是登录逻辑（Knockout + service_rpc + jquery 等模块化框架）

---

### ✅ Step B：提交登录请求（关键）

真正的登录动作发生在下面这个请求：

**请求：**

```
POST http://192.168.0.1/ubus/?t=1767842441972
```

它不是普通表单，而是 JSON-RPC：

**请求 body（HAR 中真实数据）：**

```json
[{
  "jsonrpc": "2.0",
  "id": 3541,
  "method": "call",
  "params": [
    "00000000000000000000000000000000",
    "zwrt_web",
    "web_login",
    {
      "password": "E73723411C37475B0E0D20C45AA9FD6EAB6EBA1B8707E4545C4025A07303F632"
    }
  ]
}]
```

这里你应该重点注意：

| 字段               | 含义                              |
| ---------------- | ------------------------------- |
| `method: "call"` | JSON-RPC 调用方法                   |
| `"zwrt_web"`     | ubus 的服务对象（类似 service / module） |
| `"web_login"`    | 登录方法名                           |
| `"0000..."`      | session（未登录时用全 0 session）       |
| `password`       | 不是明文，是一个 64 位 hex 串（很像 SHA256）  |

---

### ✅ Step C：登录成功后返回 Session Token

响应体：

```json
[{
  "jsonrpc":"2.0",
  "id":3541,
  "result":[0,{
    "result":0,
    "ubus_rpc_session":"136a9c33ba9cc8127d67e34d85d628ff",
    "timeout":300
  }]
}]
```

关键点：

| 字段                   | 含义                    |
| -------------------- | --------------------- |
| `result:[0,...]`     | 0 表示 ubus call 成功     |
| `"result":0`         | 登录成功（业务返回码）           |
| `"ubus_rpc_session"` | 登录态 token             |
| `"timeout":300`      | session 超时（300 秒=5分钟） |

✅ **重要：这个登录态并不是 Set-Cookie 返回的，而是放在 JSON 里返回给前端。**

---

### ✅ Step D：后续请求都携带 session

抓包中后面出现了大量 `/ubus/` 请求（你上传的 HAR 里有 28 个），这些请求 body 会携带：

* `"136a9c33ba9cc8127d67e34d85d628ff"` 这个 session token

说明：
**前端把这个 session 存下来（通常是 JS 内存变量 / localStorage / cookie），之后每次 RPC 都带上它。**

---

## 2）总结：这个系统的登录实现方式属于哪一类？

它属于 **“前端 SPA / 模块化页面 + JSON-RPC Token Session 模式”**：

* 登录页只是一个壳
* 认证通过 ubus RPC 完成
* 认证成功后返回 token session
* token session 不在 Cookie 里，而是应用层字段
* API 是 JSON-RPC 2.0（典型 OpenWrt/ubus 风格）

---

## 3）密码为什么是 64 位？是否加密？

从 HAR 看：

* `password` 是 `E737...` 这种 **64 字符的十六进制字符串**
* 很像 `SHA256(password)` 的结果（sha256 输出 32 bytes = 64 hex）

但要注意：

* 这并不等同于 “安全传输”，而是 **把密码 hash 后提交**
* 如果没有 `nonce / salt / challenge`，hash 依然可以被重放攻击

从抓包来看：

* 我没有看到登录前获取 `nonce/challenge` 的请求
* 也没有看到 server 返回随机盐

因此大概率是：

### ✅ 方式 1：直接 `SHA256(明文密码)`

风险：

* **抓到一次 hash 就可以直接复用登录**

### ✅ 方式 2：`SHA256(明文密码 + 固定盐)`

风险：

* 固定盐仍然可重放

### ✅ 更安全的应做方式：

应当是 challenge-response：

1. 前端请求 `get_nonce`
2. 服务端返回 nonce（一次性随机数）
3. 前端计算 `SHA256(password + nonce)`
4. 提交并验证
5. nonce 用过即失效

---

## 4）登录模块的前端实现（你如果要复刻的话）

从抓包可以推断 `home.js` 里逻辑大概是：

### ① 用户输入密码

```js
passwordInput
```

### ② 计算 hash

```js
hashedPwd = SHA256(passwordInput)
```

### ③ 发送 JSON-RPC 请求

```js
rpc.call("zwrt_web", "web_login", { password: hashedPwd }, session="000...0")
```

### ④ 成功后保存 session

```js
session = resp.ubus_rpc_session
```

### ⑤ 后续所有 API 调用都带 session

```js
rpc.call("xxx", "yyy", params, session)
```

---

## 5）后端（ubus）实现方式（你如果要实现类似 API）

后端需要做的事非常明确：

### ① 提供 `web_login` 方法

输入：

* password hash

逻辑：

* 取数据库/配置中保存的 hash
* 对比是否一致
* 成功后创建 session token（随机字符串）
* 存到 session 表（内存/文件/数据库）
* 返回 token 和 timeout

### ② ubus RPC session 管理

必须实现：

* session 存储结构
* session 过期清理
* session 绑定 IP / UA（建议）
* session 校验逻辑（每次 RPC call 前校验）

---

## 6）安全建议（如果你要优化这种登录方式）

### ✅ 1）一定要上 HTTPS

否则 hash 也一样会被窃听 & 重放。

### ✅ 2）加 challenge/nonce 防重放

否则攻击者只需复制 hash 就能登录。

### ✅ 3）session 绑定设备信息

绑定：

* IP
* User-Agent
* 甚至 MAC（局域网场景可考虑）

### ✅ 4）session timeout 过短 / 可刷新

当前是 300 秒，可能会频繁掉线
可以做：

* 300 秒 idle timeout
* 活跃自动刷新续期

---

# ✅ 结论（一句话总结）

你这个系统的登录实现是：
**前端登录页 home.js 计算密码哈希 → 调用 `/ubus/` JSON-RPC 的 `zwrt_web.web_login` → 后端返回 `ubus_rpc_session` token → 前端后续所有 API 都带这个 token 作为登录态。**

---

如果你愿意，我可以进一步帮你做两件事：

1. **把 HAR 中所有 `/ubus/` 请求按顺序梳理成“登录后初始化流程”**（比如登录后会获取哪些信息：网络状态、设备信息、SIM 状态等）
2. **反向推导 home.js 中登录逻辑，给你一个可以复刻的伪代码 / Demo**（包括 JSON-RPC 封装、session 管理）

你更想看哪一个？
