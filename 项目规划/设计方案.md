太好了！你把 **完整 response** 贴出来之后，我们就可以把 WPF 方案做到**完全可落地**了 ✅
而且现在已经能非常明确地回答你最关心的几个问题：

* **速率信息在哪里？单位是什么？**
* **哪些字段要展示？**
* **WPF 应该怎么解析、怎么刷新、怎么做 MVVM 架构？**
* **session 怎么处理？**
* **如何做趋势图/实时刷新？**

下面我给你一个「工程级」的实现规划 + 关键代码骨架（你可以直接拿去做项目）。

---

# ✅ 1）从 response 里确认：速率信息来自 id=46（zwrt_data.get_wwandst）

你这一段是关键：

```json
"id":46,
"result":[0,{
  "real_tx_speed":89310,
  "real_rx_speed":561796,
  "real_max_tx_speed":3120516,
  "real_max_rx_speed":30882113
}]
```

### ✅ 结论：

* **实时上传速率 = real_tx_speed**
* **实时下载速率 = real_rx_speed**
* 还有最大速率用于显示峰值

### ✅ 单位判断：

结合很多嵌入式系统（OpenWrt/ubus 常见），这两个字段一般是：

* **B/s（字节/秒）** 或 **bit/s**
* 但因为数值 561796（大约 548 KB/s），更像 **B/s**

所以你在 WPF 展示时应当做格式化：

* 89310 B/s ≈ 87.2 KB/s
* 561796 B/s ≈ 548.7 KB/s

> 这也符合你网页显示 “Kb/s” 的逻辑：前端会转换单位，不是接口直接给 Kb/s。

---

# ✅ 2）主页（Home）页面字段应该如何映射？

你现在这批 response 已经足够支持一个完整“设备仪表盘”WPF 页面。

我给你做一张「字段映射表」，你后续就很清楚 UI 显示用哪些数据：

---

## 🟦 A. WAN / IP / DNS /连接状态（id=44 与 id=55）

### id=44（router_get_status）

可用字段：

* `current_wan_status`：连接状态
* `mwan_wanlan1_wan_ipaddr`：IPv4
* `mwan_wanlan1_ipv6_wan_ipaddr`：IPv6
* DNS 信息
* 网关信息

### id=55（get_wwaniface）

更贴近接口实际状态：

* `connect_status`：ipv4_ipv6_connected
* `ipv4_address`
* `ipv4_dns_prefer`
* `ipv6_address`
* `ipv6_dns_prefer`

✅ 建议你最终 UI 上用 id=55 的字段做“网络信息展示”（更标准）

---

## 🟩 B. 速率 / 流量统计（id=46）

* `real_tx_speed`（实时上传速度）
* `real_rx_speed`（实时下载速度）
* `real_tx_bytes / real_rx_bytes`（累计实时统计）
* `day_tx_bytes / day_rx_bytes`（今日累计）
* `month_tx_bytes / month_rx_bytes`（本月累计）
* `total_tx_bytes / total_rx_bytes`（总计累计）

✅ 这个接口足够做：

* 实时速率显示
* 今日/本月/总流量统计
* 趋势图（每秒采样）

---

## 🟨 C. SIM 信息（id=47）

* `sim_states`：sim ready
* `Operator`：CMCC
* `sim_iccid`
* `sim_imsi`
* `mdm_mcc / mdm_mnc`
* `modem_main_state`：modem_init_complete
* `wlan_mac_address`

✅ 这是“设备基础信息面板”的主要数据来源。

---

## 🟥 D. 信号 / 网络类型（id=48）

* `network_type`: SA（5G SA）
* `signalbar`: 5（信号格）
* `wan_active_band`: n41
* `nr5g_rsrp / rsrq / snr`
* `lte_rsrp / rsrq / snr`
* `network_provider_fullname`

✅ 这是你 UI 上 “信号强度” 的核心来源。

---

## 🟪 E. WiFi 信息（id=53）

* `wifi_onoff`
* `main2g_ssid`
* `main5g_ssid`
* `main2g_authmode`
* `main5g_authmode`

⚠️ 注意：这个接口并没有给你 WiFi 密码（安全原因，可能另一个接口才给）

---

## 🟫 F. 设备数量（id=51）

* `access_total_num`：总设备
* `wireless_num`：无线在线
* `lan_num`：有线在线
* `offline_num`：离线

✅ 直接做设备统计卡片。

---

# ✅ 3）WPF 的最佳实现方式：一套“批量刷新”的 HomeDashboardService

你 Web 端每次刷主页就是一次批量请求 → 一次响应。

WPF 最稳的方式就是照搬：

✅ 每 1~2 秒发一次 **批量请求**（至少包含 44、46、47、48、51、53、55）

这样你能在一次响应内保证数据一致。

---

# ✅ 4）建议你采用“两个刷新频率”策略（更专业）

如果你完全照 Web 每次全部刷新会有点重（尤其是 OTA / privacy / sms 容量这些不需要秒级）。

推荐这样：

### 🔥 高频刷新（1s~2s）

用于实时展示：

* 速率（46）
* 连接状态（44/55）
* 信号（48）
* SIM 状态（47）也可以 5 秒一次

### 🧊 低频刷新（10s~30s）

用于不敏感信息：

* OTA 状态（52/56）
* WiFi report（53）
* privacy flag（54）

这样 WPF 更稳定、更省设备资源。

---

# ✅ 5）WPF 端解析这些 response 的最佳方式

你现在的 response 是：

* 外层数组：`[{id:44, result:[0,payload]}, {id:45, ...}]`
* 每个 payload 的结构不一样

**最稳做法：**

* 先按 id 做字典映射
* 对每个 id 反序列化成对应模型（强类型）
* ViewModel 只接收最终模型（不要在 UI 层搞 JsonElement）

---

## ✅ 5.1 建议定义这些模型（核心几个）

### SpeedStat（id=46）

```csharp
public class SpeedStat
{
    public long real_tx_speed { get; set; }
    public long real_rx_speed { get; set; }
    public long day_tx_bytes { get; set; }
    public long day_rx_bytes { get; set; }
    public long month_tx_bytes { get; set; }
    public long month_rx_bytes { get; set; }
    public long total_tx_bytes { get; set; }
    public long total_rx_bytes { get; set; }
}
```

### SimInfo（id=47）

```csharp
public class SimInfo
{
    public string sim_states { get; set; }
    public string Operator { get; set; }
    public string sim_iccid { get; set; }
    public string sim_imsi { get; set; }
    public string modem_main_state { get; set; }
    public string wlan_mac_address { get; set; }
}
```

### NetInfo（id=48）

```csharp
public class NetInfo
{
    public string network_type { get; set; }
    public string network_provider_fullname { get; set; }
    public string wan_active_band { get; set; }
    public string signalbar { get; set; }
    public int nr5g_rsrp { get; set; }
    public int nr5g_rsrq { get; set; }
    public string nr5g_snr { get; set; }
}
```

### DeviceCount（id=51）

```csharp
public class DeviceCount
{
    public int access_total_num { get; set; }
    public int wireless_num { get; set; }
    public int lan_num { get; set; }
    public int offline_num { get; set; }
}
```

### WifiReport（id=53）

```csharp
public class WifiReport
{
    public string wifi_onoff { get; set; }
    public string main2g_ssid { get; set; }
    public string main5g_ssid { get; set; }
    public string main2g_authmode { get; set; }
    public string main5g_authmode { get; set; }
}
```

---

# ✅ 6）WPF ViewModel 里如何展示（重点：格式化速度/流量）

你接口返回的是 bytes/s，所以你应该做一个工具类：

```csharp
public static class FormatUtil
{
    public static string FormatSpeed(long bytesPerSec)
    {
        double v = bytesPerSec;
        string[] units = { "B/s", "KB/s", "MB/s", "GB/s" };
        int i = 0;
        while (v >= 1024 && i < units.Length - 1)
        {
            v /= 1024;
            i++;
        }
        return $"{v:F1} {units[i]}";
    }

    public static string FormatBytes(long bytes)
    {
        double v = bytes;
        string[] units = { "B", "KB", "MB", "GB", "TB" };
        int i = 0;
        while (v >= 1024 && i < units.Length - 1)
        {
            v /= 1024;
            i++;
        }
        return $"{v:F2} {units[i]}";
    }
}
```

然后在 ViewModel 里：

* `UploadSpeedText = FormatUtil.FormatSpeed(speed.real_tx_speed)`
* `DownloadSpeedText = FormatUtil.FormatSpeed(speed.real_rx_speed)`
* `DayTrafficText = FormatUtil.FormatBytes(speed.day_tx_bytes + speed.day_rx_bytes)`
* `MonthTrafficText = ...`

---

# ✅ 7）完整建议：你 WPF 项目结构应该这样规划

我给你一个你照着建就不会走弯路的工程结构：

```
WpfApp
 ├── Api
 │    ├── UbusClient.cs
 │    ├── SessionManager.cs   (后续补 session create/login)
 │
 ├── Models
 │    ├── SpeedStat.cs
 │    ├── SimInfo.cs
 │    ├── NetInfo.cs
 │    ├── WifiReport.cs
 │    ├── DeviceCount.cs
 │
 ├── Services
 │    ├── HomeDashboardService.cs
 │
 ├── ViewModels
 │    ├── MainViewModel.cs
 │    ├── DashboardViewModel.cs
 │
 ├── Views
 │    ├── DashboardView.xaml
 │
 └── Utils
      ├── FormatUtil.cs
```

---

# ✅ 8）session 怎么解决？（你现在是固定 token，但 WPF 需要自动化）

你现在拿到的 session：

`7dcd9bde9c28b3a32f9754593c01d027`

WPF 里不能写死。

**下一步你需要抓一个 session 的生成接口**（一般是开页面第一条 /ubus/ 请求）。
我们要找类似：

* `"session", "create"`
* `"session", "login"`
* `"rpc-sys", "login"`

只要你把那个 payload 发我，我就能给你写完整的：

✅ 自动获取 session（匿名）
✅ 或输入账号密码登录获取 session
✅ 自动刷新并在 session 失效时重新获取

---

# ✅ 9）你现在可以直接开始做 WPF 首页了（我建议你做的第一版）

**第一版 Dashboard 只做 6 个卡片就非常完整：**

### ① 网络状态

* connect_status
* IPv4 address
* IPv6 address

### ② 实时速率

* Upload / Download

### ③ 今日 / 本月 / 总流量

* Day / Month / Total（tx+rx）

### ④ SIM 信息

* Operator / sim ready / ICCID（可隐藏后几位）

### ⑤ 信号强度

* signalbar + rsrp/rsrq/snr

### ⑥ 设备数量

* total / wireless / lan / offline

---

# ✅ 10）下一步你发我“session 创建请求”，我就能把整套代码闭环

你现在已经把“数据接口”完全确认了 ✅
唯一缺口就是 **session 的生命周期管理**。

请你再抓一次：

* 打开浏览器新开无痕窗口
* 进入 `http://192.168.0.1`
* F12 → Network → 第一条 `/ubus/` 请求（通常就是 session create）
* 把 payload/response 发我（可以把用户名密码打码）

我就能给你补齐：

✅ SessionManager（自动创建/登录）
✅ WPF 从“0”开始就能自动获取 session 并刷新 dashboard
✅ 处理 session 失效（403/ubus code 非0）自动重登

---

# ✅ 最终总结

你现在已经拿到了完整的 Home Dashboard 数据源：

* **速率：id=46 real_tx_speed / real_rx_speed（bytes/s）**
* SIM：id=47
* 信号：id=48
* 设备数：id=51
* WiFi：id=53
* 网络接口信息：id=55

所以你的 WPF 方案完全可以做到：

✅ 不嵌网页
✅ 不解析 HTML
✅ 直接走 ubus JSON-RPC
✅ 批量请求 + 定时刷新
✅ MVVM 绑定显示 + 趋势图可扩展

---

如果你愿意，我下一步可以直接给你输出一个**完整可运行的 WPF Demo（含 XAML 布局）**：

* Dashboard 六个卡片布局
* 实时刷新 2 秒
* 速率格式化
* 信号强度显示（柱状/星级）
  你只需要再提供 session 创建/登录请求即可完全闭环。
